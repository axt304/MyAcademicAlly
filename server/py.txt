import uvicorn
from datetime import datetime, timedelta
from typing import Annotated
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from passlib.context import CryptContext

from server.model import User, UserInDB, Token, TokenData, fake_users_db

SECRET_KEY = "69fe363e3c8ad17d4d8a052a17018c68394a1cba585eea0da6d89e4267b526b7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
app = FastAPI()

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)
    
def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes= 15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

#User credetials of active user
async def get_current_active_user(
        current_user: Annotated[User, Depends(get_current_user)]
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

#Example login function
@app.post("/token", response_model=Token)
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

#Test
@app.get("/", tags=["test"])
async def greet():
    return {"message": "Hello World"}

#Path to get current user
@app.get("/users/me", response_model=User)
async def read_users_me(current_user: Annotated[User, Depends(get_current_active_user)]):
    return current_user

#Example path to get projects related to a person
@app.get("/users/me/projects")
async def read_own_projects(
    current_user: Annotated[User, Depends(get_current_active_user)]
):
    return [{"project_id": "Foobar", "owner": current_user.username}]from datetime import timedelta, datetime
from typing import Annotated
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy.orm import Session
from starlette import status
from database import SesssionLocal
from model import Users
from passlib.context import CryptContext
from fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer
from jose import jwt, JWTError

router = APIRouter(
    prefix='/auth',
    tags=['auth']
)

SECRET_KEY = "69fe363e3c8ad17d4d8a052a17018c68394a1cba585eea0da6d89e4267b526b7"
ALGORITHM = "HS256"

bcrypt_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/token")

class CreateUserRequest(BaseModel):
    username: str
    passwrod: str

class Token(BaseModel):
    access_token: str
    token_type: str

import sqlalchemy
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQL_DB_URL = "maa-2.cb23pnbzjijy.us-east-1.rds.amazonaws.com"
SQL_DB_URL = "localhost"
SQL_DB_PASS = "1qaz2wsx!QAZ@WSX"
SQL_DB_PASS = "Daliilad3"
SQL_DB_PASS_NOAT = "1qaz2wsx!QAZ%40WSX"

SQL_DB = sqlalchemy.engine.URL.create(
        drivername="mysql",
        username="root",
        password=SQL_DB_PASS,
        host=SQL_DB_URL,
        database="academicAlly",
)

engine = create_engine(
    SQL_DB
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()
Base.metadata.create_all(bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
from fastapi import FastAPI
from fastapi.responses import JSONResponse
from pydantic import BaseModel

import project, task, user

app = FastAPI()
app.include_router(project.router)
app.include_router(task.router)
app.include_router(user.router)

#engine=create_engine(SQL_DB)
#SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
#Base = declerative_base()

@app.get("/")
async def greet():
    return {"message": "Hello World"}

from pydantic import BaseModel

#Example model, used for prototype, NOT SECURE
class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str  | None = None
    disabled: bool  | None = None 

#Fake user data for prototype
fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
        "disabled": False,
    },
    "janedoe": {
        "username": "janedoe",
        "full_name": "Jane Doe",
        "email": "janedoe@example.com",
        "hashed_password": "fakehashedsecret2",
        "disabled": True,
    }    
}

class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy import Boolean, Column, ForeignKey, Integer, String
from sqlalchemy.orm import relationship, Session

from db import Base, get_db

from user import UserData

router = APIRouter()

class ProjectData(Base):
    __tablename__ = "projects"
    id = Column(Integer, primary_key=True, autoincrement=True, index=True)
    name = Column(String, unique=True)
    color = Column(String)
    user_id = Column(ForeignKey("users.id"))
    

class Project(BaseModel):
    name: str
    color: str
    user_id: int
    class Config:
        orm_mode = True

@router.post("/api/projects", tags=["projects"])
def create_project(project: Project, db: Session = Depends(get_db)):
    pdata = ProjectData(name=project.name, color=project.color, user_id=project.user_id)
    db.add(pdata)
    db.commit()
    db.refresh(pdata)
    return {"message": "Project created successfully"}

@router.get("/api/projects/{project_id}", tags=["projects"])
def get_project(project_id: int, db: Session = Depends(get_db)):
    pdata = fetch_project_by_id(db, project_id)
    if pdata is None:
        raise HTTPException(status_code=404, detail="Project not found")
    return Project(name=pdata.name, color=pdata.color, user_id=pdata.user_id).dict()

@router.put("/api/projects/{project_id}", tags=["projects"])
def update_project(project_id: int, project: Project, db: Session = Depends(get_db)):
    db.query(ProjectData).filter(project_id==ProjectData.id).update(project.dict())
    db.commit()
    return {"message": "Project updated successfully"}

@router.delete("/api/projects/{project_id}", tags=["projects"])
def delete_project(project_id: int, db: Session = Depends(get_db)):
    db.query(ProjectData).filter(project_id==ProjectData.id).delete()
    db.commit()
    return {"message": "Project deleted successfully"}

def fetch_project_by_id(db: Session, project_id: int):
    return db.query(ProjectData).filter(ProjectData.id == project_id).first()
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy import Boolean, Column, ForeignKey, Integer, String
from sqlalchemy.orm import relationship, Session

from db import Base, get_db

router = APIRouter()

class TaskData(Base):
    __tablename__ = "tasks"
    id = Column(Integer, primary_key=True, autoincrement=True, index=True)
    name = Column(String)
    description = Column(String)
    due_date = Column(String)
    user_id = Column(ForeignKey("users.id"))
    project_id = Column(ForeignKey("projects.id"))

class Task(BaseModel):
    name: str
    description: str
    due_date: str
    user_id: int
    project_id: int
    class Config:
        orm_mode = True

@router.post("/api/tasks", tags=["tasks"])
def create_task(task: Task, db: Session = Depends(get_db)):
    tdata = TaskData(name=task.name, description=task.description, due_date=task.due_date, user_id=task.user_id, project_id=task.project_id)
    db.add(tdata)
    db.commit()
    db.refresh(tdata)
    return {"message": "Task created successfully"}

@router.get("/api/tasks/{task_id}", tags=["tasks"])
def get_task(task_id: int, db: Session = Depends(get_db)):
    tdata = fetch_task_by_id(task_id)
    if tdata is None:
        raise HTTPException(status_code=404, detail="Task not found")
    return Task(name=tdata.name, description=tdata.description, due_date=tdata.due_date, user_id=tdata.user_id, project_id=tdata.project_id).dict()

@router.put("/api/tasks/{task_id}", tags=["tasks"])
def update_task(task_id: int, task: Task, db: Session = Depends(get_db)):
    tdata = fetch_task_by_id(db, task_id)
    db.query(TaskData).filter(task_id==TaskData.id).update(tdata.dict())
    db.commit()
    return {"message": "Task updated successfully"}

@router.delete("/api/tasks/{task_id}", tags=["tasks"])
def delete_task(task_id: int, db: Session = Depends(get_db)):
    db.query(TaskData).filter(task_id==TaskData.id).delete()
    db.commit()
    return {"message": "Task deleted successfully"}

def fetch_task_by_id(db: Session, task_id: int):
    return db.query(TaskData).filter(TaskData.id == task_id).first()
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy import Boolean, Column, ForeignKey, Integer, String
from sqlalchemy.orm import relationship, Session

from db import Base, get_db

router = APIRouter()

#sql tables must be made specifying non-null, autoincrement primary keys

class UserData(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, autoincrement=True, index=True)
    name = Column(String)
    password = Column(String)
    email = Column(String, unique=True)

class User(BaseModel):
    name: str
    password: str
    email: str
    class Config:
        orm_mode = True

@router.post("/api/users", tags=["users"])
def create_user(user: User, db: Session = Depends(get_db)):
    udata = fetch_user_by_email(db, user.email)
    if udata is not None:
        raise HTTPException(status_code=403, detail="Email in use")
    udata = UserData(name=user.name, password=user.password, email=user.email)
    db.add(udata)
    db.commit()
    db.refresh(udata)
    return {"message": "User created successfully"}

@router.get("/api/users/{user_id}", tags=["users"], response_model=User)
def get_user(user_id: int, db: Session = Depends(get_db)):
    udata = fetch_user_by_id(db, user_id)
    if udata is None:
        raise HTTPException(status_code=404, detail="User not found")
    return User(name=udata.name, password=udata.password, email=udata.email).dict()

@router.put("/api/users/{user_id}", tags=["users"])
def update_user(user_id: int, user: User, db: Session = Depends(get_db)):
    db.query(UserData).filter(user_id == UserData.id).update(user.dict())
    db.commit()
    return {"message": "Updated user successfully"}

@router.delete("/api/users/{user_id}", tags=["users"])
def delete_user(user_id: int, db: Session = Depends(get_db)):
    db.query(UserData).filter(user_id == UserData.id).delete()
    db.commit()
    return {"message": "Deleted user successfully"}

def fetch_user_by_id(db: Session, user_id: int):
    return db.query(UserData).filter(UserData.id == user_id).first()

def fetch_user_by_email(db: Session, email: str):
    return db.query(UserData).filter(UserData.email == email).first()
